-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algorithms for coin selection and fee balancing.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-coin-selection</a>
@package cardano-coin-selection
@version 1.0.0


-- | <b>Submodules</b> of this module provide implementations of <b>coin
--   selection algorithms</b>.
--   
--   Algorithms can be divided into two categories:
--   
--   <ul>
--   <li><a>Generalized Algorithms</a>Algorithms that implement the general
--   <a>CoinSelectionAlgorithm</a> interface.</li>
--   <li><a>Specialized Algorithms</a>Algorithms that provide functionality
--   suited to specialized purposes.</li>
--   </ul>
--   
--   <h1>Generalized Algorithms </h1>
--   
--   The following algorithms implement the general
--   <a>CoinSelectionAlgorithm</a> interface:
--   
--   <ul>
--   <li><b><a>Cardano.CoinSelection.Algorithm.LargestFirst</a></b>Provides
--   an implementation of the <b>Largest-First</b> algorithm.When selecting
--   inputs from a given set of UTxO entries, this algorithm always selects
--   the <i>largest</i> entries <i>first</i>.</li>
--   
--   <li><b><a>Cardano.CoinSelection.Algorithm.RandomImprove</a></b>Provides
--   an implementation of the <b>Random-Improve</b> algorithm.When
--   selecting inputs from a given set of UTxO entries, this algorithm
--   always selects entries at <i>random</i>.Once selections have been
--   made, a second phase attempts to <i>improve</i> on each of the
--   existing selections in order to optimize change outputs.</li>
--   </ul>
--   
--   For <b>guidance on choosing an algorithm</b> that's appropriate for
--   your scenario, please consult the following article:
--   
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
--   
--   <h1>Specialized Algorithms </h1>
--   
--   The following algorithms provide functionality suited to specialized
--   purposes:
--   
--   <ul>
--   <li><b><a>Cardano.CoinSelection.Algorithm.Migration</a></b>Provides an
--   algorithm for migrating all funds from one wallet to another.</li>
--   </ul>
module Cardano.CoinSelection.Algorithm


-- | Provides general functions and types relating to coin selection.
--   
--   The <a>CoinSelection</a> type represents a <b>coin selection</b>, the
--   basis for a <i>transaction</i> in a UTxO-based blockchain.
--   
--   The <a>CoinSelectionAlgorithm</a> type provides a <b>common
--   interface</b> to algorithms that generate coin selections.
--   
--   For a guide to <b>algorithms provided by this library</b>, see the
--   <a>Cardano.CoinSelection.Algorithm</a> module.
--   
--   To adjust coin selections in order to <b>pay for transaction fees</b>,
--   see the <a>Cardano.CoinSelection.Fee</a> module.
module Cardano.CoinSelection

-- | A <b>coin selection</b> is the basis for a <i>transaction</i>.
--   
--   It consists of a selection of <a>inputs</a>, <a>outputs</a>, and
--   <a>change</a>.
--   
--   The <a>inputs</a> and <a>outputs</a> fields are both maps of unique
--   keys to associated <a>Coin</a> values, where:
--   
--   <ul>
--   <li>Each key-value pair in the <a>inputs</a> map corresponds to an
--   <b>unspent output</b> from a previous transaction (also known as a
--   UTxO). The <i>key</i> is a unique reference to that output, and the
--   <i>value</i> is the amount of unspent value associated with it.</li>
--   <li>Each key-value pair in the <a>outputs</a> map corresponds to a
--   <b>payment</b>. The <i>key</i> is a unique reference to a payment
--   recipient, and the <i>value</i> is the amount of money to pay to that
--   recipient.</li>
--   </ul>
--   
--   The <a>change</a> field is a set of coins to be returned to the
--   originator of the transaction.
--   
--   The <a>CoinSelectionAlgorithm</a> type provides a common interface for
--   generating coin selections.
data CoinSelection i o
CoinSelection :: CoinMap i -> CoinMap o -> [Coin] -> CoinSelection i o

-- | The set of inputs.
[inputs] :: CoinSelection i o -> CoinMap i

-- | The set of outputs.
[outputs] :: CoinSelection i o -> CoinMap o

-- | The set of change.
[change] :: CoinSelection i o -> [Coin]

-- | Calculate the total sum of all <a>inputs</a> for the given
--   <a>CoinSelection</a>.
sumInputs :: CoinSelection i o -> Coin

-- | Calculate the total sum of all <a>outputs</a> for the given
--   <a>CoinSelection</a>.
sumOutputs :: CoinSelection i o -> Coin

-- | Calculate the total sum of all <a>change</a> for the given
--   <a>CoinSelection</a>.
sumChange :: CoinSelection i o -> Coin

-- | Provides a <b>common interface</b> for coin selection algorithms.
--   
--   The function <a>selectCoins</a>, when applied to the given
--   <a>CoinSelectionParameters</a> object (with <i>available inputs</i>
--   and <i>requested</i> <i>outputs</i>), will generate a
--   <a>CoinSelectionResult</a> (with <i>remaining inputs</i> and a <i>coin
--   selection</i>).
--   
--   For implementations provided by this library, see
--   <a>Cardano.CoinSelection.Algorithm</a>.
newtype CoinSelectionAlgorithm i o m
CoinSelectionAlgorithm :: (CoinSelectionParameters i o -> ExceptT CoinSelectionError m (CoinSelectionResult i o)) -> CoinSelectionAlgorithm i o m
[selectCoins] :: CoinSelectionAlgorithm i o m -> CoinSelectionParameters i o -> ExceptT CoinSelectionError m (CoinSelectionResult i o)

-- | The complete set of parameters required for a
--   <a>CoinSelectionAlgorithm</a>.
--   
--   The <a>inputsAvailable</a> and <a>outputsRequested</a> fields are both
--   maps of unique keys to associated <a>Coin</a> values, where:
--   
--   <ul>
--   <li>Each key-value pair in the <a>inputsAvailable</a> map corresponds
--   to an <b>unspent output</b> from a previous transaction that is
--   <i>available</i> <i>for selection as an input</i> by the coin
--   selection algorithm. The <i>key</i> is a unique reference to that
--   output, and the <i>value</i> is the amount of unspent value associated
--   with it.</li>
--   <li>Each key-value pair in the <a>outputsRequested</a> map corresponds
--   to a <b>payment</b> whose value is <i>to be paid for</i> by the coin
--   selection algorithm. The <i>key</i> is a unique reference to a payment
--   recipient, and the <i>value</i> is the amount of money to pay to that
--   recipient.</li>
--   </ul>
--   
--   A coin selection algorithm will select a <b>subset</b> of inputs from
--   <a>inputsAvailable</a> in order to pay for <b>all</b> the outputs in
--   <a>outputsRequested</a>, where:
--   
--   <ul>
--   <li>Inputs <b>selected</b> by the algorithm are included in the
--   <a>inputs</a> set of the generated <a>CoinSelection</a>.</li>
--   <li>Inputs <b>not</b> selected by the algorithm are included in the
--   <a>inputsRemaining</a> set of the <a>CoinSelectionResult</a>.</li>
--   </ul>
--   
--   The number of inputs that can selected is limited by <a>limit</a>.
--   
--   The total value of <a>inputsAvailable</a> must be <i>greater than or
--   equal to</i> the total value of <a>outputsRequested</a>, as given by
--   the <a>coinMapValue</a> function.
data CoinSelectionParameters i o
CoinSelectionParameters :: CoinMap i -> CoinMap o -> CoinSelectionLimit -> CoinSelectionParameters i o

-- | The set of inputs available for selection.
[inputsAvailable] :: CoinSelectionParameters i o -> CoinMap i

-- | The set of outputs requested for payment.
[outputsRequested] :: CoinSelectionParameters i o -> CoinMap o

-- | A limit on the number of inputs that can be selected.
[limit] :: CoinSelectionParameters i o -> CoinSelectionLimit

-- | Represents the <b>result</b> of running a coin selection algorithm.
--   
--   See <a>CoinSelectionAlgorithm</a>.
data CoinSelectionResult i o
CoinSelectionResult :: CoinSelection i o -> CoinMap i -> CoinSelectionResult i o

-- | The generated coin selection.
[coinSelection] :: CoinSelectionResult i o -> CoinSelection i o

-- | The set of inputs that were <b>not</b> selected.
[inputsRemaining] :: CoinSelectionResult i o -> CoinMap i

-- | Defines an <b>inclusive upper bound</b> on the <i>number</i> of inputs
--   that a <a>CoinSelectionAlgorithm</a> is allowed to select.
newtype CoinSelectionLimit
CoinSelectionLimit :: (Word16 -> Word16) -> CoinSelectionLimit

-- | Calculate the maximum number of inputs allowed for a given number of
--   outputs.
[calculateLimit] :: CoinSelectionLimit -> Word16 -> Word16

-- | Represents a non-negative integral amount of currency.
--   
--   Use <a>coinFromNatural</a> to create a coin from a natural number.
--   
--   Use <a>coinToNatural</a> to convert a coin into a natural number.
data Coin

-- | Creates a coin from a natural number.
coinFromNatural :: Natural -> Coin

-- | Converts the given coin into a natural number.
coinToNatural :: Coin -> Natural

-- | A mapping from unique keys to associated <a>Coin</a> values.
--   
--   A <a>CoinMap</a> can be used to represent:
--   
--   <ul>
--   <li>a UTxO set, where each key within the map refers to an unspent
--   output from a previous transaction.</li>
--   <li>a set of <a>inputs</a> to a <a>CoinSelection</a>, where each input
--   is an entry selected from a UTxO set by a
--   <a>CoinSelectionAlgorithm</a>.</li>
--   <li>a set of <a>outputs</a> for a <a>CoinSelection</a>, where each key
--   within the map refers to the address of a payment recipient.</li>
--   </ul>
--   
--   A <a>CoinMap</a> can be constructed with the <a>coinMapFromList</a>
--   function.
--   
--   The total value of a <a>CoinMap</a> is given by the
--   <a>coinMapValue</a> function.
newtype CoinMap a
CoinMap :: Map a Coin -> CoinMap a
[unCoinMap] :: CoinMap a -> Map a Coin

-- | An entry for a <a>CoinMap</a>.
data CoinMapEntry a
CoinMapEntry :: a -> Coin -> CoinMapEntry a

-- | The unique key associated with this entry.
[entryKey] :: CoinMapEntry a -> a

-- | The coin value associated with this entry.
[entryValue] :: CoinMapEntry a -> Coin

-- | Constructs a <a>CoinMap</a> from a list of entries.
--   
--   See <a>CoinMapEntry</a>.
coinMapFromList :: Ord a => [CoinMapEntry a] -> CoinMap a

-- | Converts a <a>CoinMap</a> to a list of entries.
--   
--   See <a>CoinMapEntry</a>.
coinMapToList :: CoinMap a -> [CoinMapEntry a]

-- | Calculates the total coin value associated with a <a>CoinMap</a>.
coinMapValue :: CoinMap a -> Coin

-- | Represents the set of possible failures that can occur when attempting
--   to produce a <a>CoinSelection</a> with a
--   <a>CoinSelectionAlgorithm</a>.
--   
--   See <a>selectCoins</a>.
data CoinSelectionError
InputValueInsufficient :: InputValueInsufficientError -> CoinSelectionError
InputCountInsufficient :: InputCountInsufficientError -> CoinSelectionError
InputLimitExceeded :: InputLimitExceededError -> CoinSelectionError
InputsExhausted :: InputsExhaustedError -> CoinSelectionError

-- | Indicates that the total value of <a>inputsAvailable</a> is less than
--   the total value of <a>outputsRequested</a>, making it
--   <i>impossible</i> to cover all payments, <i>regardless</i> of which
--   algorithm is chosen.
data InputValueInsufficientError
InputValueInsufficientError :: Coin -> Coin -> InputValueInsufficientError

-- | The total value of <a>inputsAvailable</a>.
[inputValueAvailable] :: InputValueInsufficientError -> Coin

-- | The total value of <a>outputsRequested</a>.
[inputValueRequired] :: InputValueInsufficientError -> Coin

-- | Indicates that the total count of entries in <a>inputsAvailable</a> is
--   <i>fewer</i> <i>than</i> required by the algorithm. The number
--   required depends on the particular algorithm implementation.
data InputCountInsufficientError
InputCountInsufficientError :: Natural -> Natural -> InputCountInsufficientError

-- | The number of entries in <a>inputsAvailable</a>.
[inputCountAvailable] :: InputCountInsufficientError -> Natural

-- | The number of entries required.
[inputCountRequired] :: InputCountInsufficientError -> Natural

-- | Indicates that the coin selection algorithm is unable to cover the
--   total value of <a>outputsRequested</a> without exceeding the maximum
--   number of inputs defined by <a>limit</a>.
--   
--   See <a>calculateLimit</a>.
newtype InputLimitExceededError
InputLimitExceededError :: Word16 -> InputLimitExceededError
[calculatedInputLimit] :: InputLimitExceededError -> Word16

-- | Indicates that all available entries in <a>inputsAvailable</a> were
--   depleted <i>before</i> all the payments in <a>outputsRequested</a>
--   could be paid for.
--   
--   This condition can occur <i>even if</i> the total value of
--   <a>inputsAvailable</a> is greater than or equal to the total value of
--   <a>outputsRequested</a>, due to differences in the way that algorithms
--   select inputs.
data InputsExhaustedError
InputsExhaustedError :: InputsExhaustedError
instance GHC.Show.Show Cardano.CoinSelection.CoinSelectionError
instance GHC.Classes.Eq Cardano.CoinSelection.CoinSelectionError
instance GHC.Show.Show Cardano.CoinSelection.InputLimitExceededError
instance GHC.Classes.Eq Cardano.CoinSelection.InputLimitExceededError
instance GHC.Show.Show Cardano.CoinSelection.InputsExhaustedError
instance GHC.Classes.Eq Cardano.CoinSelection.InputsExhaustedError
instance GHC.Show.Show Cardano.CoinSelection.InputCountInsufficientError
instance GHC.Classes.Eq Cardano.CoinSelection.InputCountInsufficientError
instance GHC.Show.Show Cardano.CoinSelection.InputValueInsufficientError
instance GHC.Classes.Eq Cardano.CoinSelection.InputValueInsufficientError
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinSelectionParameters i o)
instance GHC.Generics.Generic Cardano.CoinSelection.CoinSelectionLimit
instance (GHC.Classes.Eq i, GHC.Classes.Eq o) => GHC.Classes.Eq (Cardano.CoinSelection.CoinSelection i o)
instance (GHC.Show.Show i, GHC.Show.Show o) => GHC.Show.Show (Cardano.CoinSelection.CoinSelection i o)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinSelection i o)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.CoinSelection.CoinMap a)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.CoinSelection.CoinMap a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord o) => GHC.Base.Semigroup (Cardano.CoinSelection.CoinSelection i o)
instance (GHC.Classes.Ord i, GHC.Classes.Ord o) => GHC.Base.Monoid (Cardano.CoinSelection.CoinSelection i o)
instance Data.Foldable.Foldable Cardano.CoinSelection.CoinMap
instance GHC.Classes.Ord a => GHC.Base.Monoid (Cardano.CoinSelection.CoinMap a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Cardano.CoinSelection.CoinMap a)


-- | This module contains an implementation of the <b>Random-Improve</b>
--   coin selection algorithm.
module Cardano.CoinSelection.Algorithm.RandomImprove

-- | An implementation of the <b>Random-Improve</b> coin selection
--   algorithm.
--   
--   <h1>Overview</h1>
--   
--   The <b>Random-Improve</b> coin selection algorithm works in <b>two
--   phases</b>, by <i>first</i> selecting UTxO entries <i>at random</i> to
--   pay for each of the given outputs, and <i>then</i> attempting to
--   <i>improve</i> upon each of the selections.
--   
--   <h3>Phase 1: Random Selection</h3>
--   
--   <b>In this phase, the algorithm randomly selects a minimal set of
--   UTxO</b> <b>entries to pay for each of the given outputs.</b>
--   
--   During this phase, the algorithm:
--   
--   <ul>
--   <li>processes outputs in <i>descending order of coin value</i>.</li>
--   <li>maintains a <i>remaining UTxO set</i>, initially equal to the
--   given <i>UTxO set</i> parameter.</li>
--   </ul>
--   
--   For each output of value <b><i>v</i></b>, the algorithm
--   <i>randomly</i> selects entries from the <i>remaining UTxO set</i>,
--   until the total value of selected entries is greater than or equal to
--   <b><i>v</i></b>. The selected entries are then associated with that
--   output, and removed from the <i>remaining UTxO set</i>.
--   
--   This phase ends when every output has been associated with a selection
--   of UTxO entries.
--   
--   However, if the remaining UTxO set is completely exhausted before all
--   outputs can be processed, the algorithm terminates with an error.
--   
--   <h3>Phase 2: Improvement</h3>
--   
--   <b>In this phase, the algorithm attempts to improve upon each of the
--   UTxO</b> <b>selections made in the previous phase, by conservatively
--   expanding the</b> <b>selection made for each output.</b>
--   
--   During this phase, the algorithm:
--   
--   <ul>
--   <li>processes outputs in <i>ascending order of coin value</i>.</li>
--   <li>continues to maintain the <i>remaining UTxO set</i> produced by
--   the previous phase.</li>
--   <li>maintains an <i>accumulated coin selection</i>, which is initially
--   <i>empty</i>.</li>
--   </ul>
--   
--   For each output of value <b><i>v</i></b>, the algorithm:
--   
--   <ol>
--   <li><b>Calculates a <i>target range</i></b> for the total value of
--   inputs used to pay for that output, defined by the
--   triplet:(<i>minimum</i>, <i>ideal</i>, <i>maximum</i>) = (<i>v</i>,
--   <i>2v</i>, <i>3v</i>)</li>
--   <li><b>Attempts to <i>improve</i> upon the <i>existing UTxO
--   selection</i></b> for that output, by repeatedly selecting additional
--   entries at random from the <i>remaining UTxO set</i>, stopping when
--   the selection can be improved upon no further.A selection with value
--   <i>v1</i> is considered to be an <i>improvement</i> over a selection
--   with value <i>v0</i> if <b>all</b> of the following conditions are
--   satisfied:<ul><li><b>Condition 1</b>: we have moved closer to the
--   <i>ideal</i> value:abs (<i>ideal</i> − <i>v1</i>) &lt; abs
--   (<i>ideal</i> − <i>v0</i>)</li><li><b>Condition 2</b>: we have not
--   exceeded the <i>maximum</i> value:<i>v1</i> ≤
--   <i>maximum</i></li><li><b>Condition 3</b>: when counting cumulatively
--   across all outputs considered so far, we have not selected more than
--   the <i>maximum</i> number of UTxO entries specified by
--   <a>limit</a>.</li></ul></li>
--   <li><b>Creates a <i>change value</i></b> for the output, equal to the
--   total value of the <i>final UTxO selection</i> for that output minus
--   the value <i>v</i> of that output.</li>
--   <li><b>Updates the <i>accumulated coin selection</i></b>:<ul><li>Adds
--   the <i>output</i> to <a>outputs</a>.</li><li>Adds the <i>improved UTxO
--   selection</i> to <a>inputs</a>.</li><li>Adds the <i>change value</i>
--   to <a>change</a>.</li></ul></li>
--   </ol>
--   
--   This phase ends when every output has been processed, <b>or</b> when
--   the <i>remaining UTxO set</i> has been exhausted, whichever occurs
--   sooner.
--   
--   <h1>Termination</h1>
--   
--   When both phases are complete, the algorithm terminates.
--   
--   The <i>accumulated coin selection</i> and <i>remaining UTxO set</i>
--   are returned to the caller.
--   
--   <h3>Failure Modes</h3>
--   
--   The algorithm terminates with an <b>error</b> if:
--   
--   <ol>
--   <li>The <i>total value</i> of the initial UTxO set (the amount of
--   money <i>available</i>) is <i>less than</i> the total value of the
--   output list (the amount of money <i>required</i>).See:
--   <b><a>InputValueInsufficientError</a></b>.</li>
--   <li>The <i>number</i> of entries in the initial UTxO set is <i>smaller
--   than</i> the number of requested outputs.Due to the nature of the
--   algorithm, <i>at least one</i> UTxO entry is required <i>for each</i>
--   output.See: <b><a>InputCountInsufficientError</a></b>.</li>
--   <li>Due to the particular <i>distribution</i> of values within the
--   initial UTxO set, the algorithm depletes all entries from the UTxO set
--   <i>before</i> it is able to pay for all requested outputs.See:
--   <b><a>InputsExhaustedError</a></b>.</li>
--   <li>The <i>number</i> of UTxO entries needed to pay for the requested
--   outputs would <i>exceed</i> the upper limit specified by
--   <a>limit</a>.See: <b><a>InputLimitExceededError</a></b>.</li>
--   </ol>
--   
--   <h1>Motivating Principles</h1>
--   
--   There are several motivating principles behind the design of the
--   algorithm.
--   
--   <h3>Principle 1: Dust Management</h3>
--   
--   The probability that random selection will choose dust entries from a
--   UTxO set increases with the proportion of dust in the set.
--   
--   Therefore, for a UTxO set with a large amount of dust, there's a high
--   probability that a random subset will include a large amount of dust.
--   
--   <h3>Principle 2: Change Management</h3>
--   
--   Ideally, coin selection algorithms should, over time, create a UTxO
--   set that has <i>useful</i> outputs: outputs that will allow us to
--   process future payments with a minimum number of inputs.
--   
--   If for each payment request of value <b><i>v</i></b> we create a
--   change output of <i>roughly</i> the same value <b><i>v</i></b>, then
--   we will end up with a distribution of change values that matches the
--   typical value distribution of payment requests.
--   
--   <h3>Principle 3: Performance Management</h3>
--   
--   Searching the UTxO set for additional entries to improve our change
--   outputs is <i>only</i> useful if the UTxO set contains entries that
--   are sufficiently small enough. But it is precisely when the UTxO set
--   contains many small entries that it is less likely for a
--   randomly-chosen UTxO entry to push the total above the upper bound.
randomImprove :: (Ord i, Ord o, MonadRandom m) => CoinSelectionAlgorithm i o m


-- | This module contains an implementation of the <b>Largest-First</b>
--   coin selection algorithm.
module Cardano.CoinSelection.Algorithm.LargestFirst

-- | An implementation of the <b>Largest-First</b> coin selection
--   algorithm.
--   
--   <h1>Overview</h1>
--   
--   The <b>Largest-First</b> algorithm processes outputs in <i>descending
--   order of</i> <i>value</i>, from <i>largest</i> to <i>smallest</i>.
--   
--   For each output, it repeatedly selects the <i>largest</i> remaining
--   unspent UTxO entry until the value of selected entries is greater than
--   or equal to the value of that output.
--   
--   <h1>State Maintained by the Algorithm</h1>
--   
--   At all stages of processing, the algorithm maintains:
--   
--   <ol>
--   <li>A <b><i>remaining UTxO list</i></b>This is initially equal to the
--   given <i>initial UTxO set</i> parameter, sorted into <i>descending
--   order of coin value</i>.The <i>head</i> of the list is always the
--   remaining UTxO entry with the <i>largest coin value</i>.Entries are
--   incrementally removed from the <i>head</i> of the list as the
--   algorithm proceeds, until the list is empty.</li>
--   <li>An <b><i>unpaid output list</i></b>This is initially equal to the
--   given <i>output list</i> parameter, sorted into <i>descending order of
--   coin value</i>.The <i>head</i> of the list is always the unpaid output
--   with the <i>largest coin value</i>.Entries are incrementally removed
--   from the <i>head</i> of the list as the algorithm proceeds, until the
--   list is empty.</li>
--   <li>An <b><i>accumulated coin selection</i></b>This is initially
--   <i>empty</i>.Entries are incrementally added as each output is paid
--   for, until the <i>unpaid output list</i> is empty.</li>
--   </ol>
--   
--   <h1>Cardinality Rules</h1>
--   
--   The algorithm requires that:
--   
--   <ol>
--   <li>Each output from the given <i>output list</i> is paid for by
--   <i>one or more</i> entries from the <i>initial UTxO set</i>.</li>
--   <li>Each entry from the <i>initial UTxO set</i> is used to pay for
--   <i>at most one</i> output from the given <i>output list</i>.(A single
--   UTxO entry <b>cannot</b> be used to pay for multiple outputs.)</li>
--   </ol>
--   
--   <h1>Order of Processing</h1>
--   
--   The algorithm proceeds according to the following sequence of steps:
--   
--   <ul>
--   <li><i>Step 1</i>Remove a single <i>unpaid output</i> from the head of
--   the <i>unpaid output list</i>.</li>
--   <li><i>Step 2</i>Repeatedly remove UTxO entries from the head of the
--   <i>remaining UTxO list</i> until the total value of entries removed is
--   <i>greater than or equal to</i> the value of the <i>removed
--   output</i>.</li>
--   <li><i>Step 3</i>Use the <i>removed UTxO entries</i> to pay for the
--   <i>removed output</i>.This is achieved by:<ul><li>adding the
--   <i>removed UTxO entries</i> to the <a>inputs</a> field of the
--   <i>accumulated coin selection</i>.</li><li>adding the <i>removed
--   output</i> to the <a>outputs</a> field of the <i>accumulated coin
--   selection</i>.</li></ul></li>
--   <li><i>Step 4</i>If the <i>total value</i> of the <i>removed UTxO
--   entries</i> is greater than the value of the <i>removed output</i>,
--   generate a coin whose value is equal to the exact difference, and add
--   it to the <a>change</a> field of the <i>accumulated coin
--   selection</i>.</li>
--   <li><i>Step 5</i>If the <i>unpaid output list</i> is empty,
--   <b>terminate</b> here.Otherwise, return to <i>Step 1</i>.</li>
--   </ul>
--   
--   <h1>Termination</h1>
--   
--   The algorithm terminates <b>successfully</b> if the <i>remaining UTxO
--   list</i> is not depleted before the <i>unpaid output list</i> can be
--   fully depleted (i.e., if all the outputs have been paid for).
--   
--   The <i>accumulated coin selection</i> and <i>remaining UTxO list</i>
--   are returned to the caller.
--   
--   <h3>Failure Modes</h3>
--   
--   The algorithm terminates with an <b>error</b> if:
--   
--   <ol>
--   <li>The <i>total value</i> of the initial UTxO set (the amount of
--   money <i>available</i>) is <i>less than</i> the total value of the
--   output list (the amount of money <i>required</i>).See:
--   <b><a>InputValueInsufficientError</a></b>.</li>
--   <li>The <i>number</i> of entries in the initial UTxO set is <i>smaller
--   than</i> the number of requested outputs.Due to the nature of the
--   algorithm, <i>at least one</i> UTxO entry is required <i>for each</i>
--   output.See: <b><a>InputCountInsufficientError</a></b>.</li>
--   <li>Due to the particular <i>distribution</i> of values within the
--   initial UTxO set, the algorithm depletes all entries from the UTxO set
--   <i>before</i> it is able to pay for all requested outputs.See:
--   <b><a>InputsExhaustedError</a></b>.</li>
--   <li>The <i>number</i> of UTxO entries needed to pay for the requested
--   outputs would <i>exceed</i> the upper limit specified by
--   <a>limit</a>.See: <b><a>InputLimitExceededError</a></b>.</li>
--   </ol>
largestFirst :: (Ord i, Ord o, Monad m) => CoinSelectionAlgorithm i o m


-- | Provides functionality for <b>adjusting</b> coin selections in order
--   to pay for transaction <b>fees</b>.
module Cardano.CoinSelection.Fee

-- | Represents a non-negative fee to be paid on a transaction.
newtype Fee
Fee :: Coin -> Fee
[unFee] :: Fee -> Coin

-- | Provides a function capable of <b>estimating</b> the transaction fee
--   required for a given coin selection, according to the rules of a
--   particular blockchain.
--   
--   The fee estimate should be a function of the <b>current</b>
--   memberships of the <a>inputs</a>, <a>outputs</a>, and <a>change</a>
--   sets.
--   
--   Depending on the rules of the blockchain under consideration, the fee
--   estimate may take either (or both) of the following factors into
--   account:
--   
--   <ul>
--   <li>the number of entries in each set;</li>
--   <li>the coin value of each set member.</li>
--   </ul>
--   
--   A fee estimate may differ from the final fee required for a selection,
--   as fees are generally paid for by <i>adjusting</i> a given selection
--   to make a <i>new</i> selection. See <a>adjustForFee</a> for more
--   details of this process.
newtype FeeEstimator i o
FeeEstimator :: (CoinSelection i o -> Fee) -> FeeEstimator i o
[estimateFee] :: FeeEstimator i o -> CoinSelection i o -> Fee

-- | Adjusts the given <a>CoinSelection</a> in order to pay for a
--   <b>transaction</b> <b>fee</b>, required in order to publish the
--   selection as a transaction on a blockchain.
--   
--   <h2>Background</h2>
--   
--   Implementations of <a>CoinSelectionAlgorithm</a> generally produce
--   coin selections that are <i>exactly balanced</i>, satisfying the
--   following equality:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs s = sumOutputs s + sumChange s
--   </pre>
--   
--   In order to pay for a transaction fee, the above equality must be
--   transformed into an <i>inequality</i>:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs s &gt; sumOutputs s + sumChange s
--   </pre>
--   
--   The difference between these two sides represents value to be paid
--   <i>by the</i> <i>originator</i> of the transaction, in the form of a
--   fee:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs s = sumOutputs s + sumChange s + fee
--   </pre>
--   
--   <h2>The Adjustment Process</h2>
--   
--   In order to generate a fee that is acceptable to the network, this
--   function adjusts the <a>change</a> and <a>inputs</a> of the given
--   <a>CoinSelection</a>, consulting the <a>FeeEstimator</a> as a guide
--   for how much the current selection would cost to publish as a
--   transaction on the network.
--   
--   <h2>Methods of Adjustment</h2>
--   
--   There are two methods of adjustment possible:
--   
--   <ol>
--   <li>The <b><a>change</a></b> set can be <i>reduced</i>, either by:a.
--   completely removing a change value from the set; or byb. reducing a
--   change value to a lower value.</li>
--   <li>The <b><a>inputs</a></b> set can be <i>augmented</i>, by selecting
--   additional inputs from the specified <a>CoinMap</a> argument.</li>
--   </ol>
--   
--   <h2>Dealing with Dust Values</h2>
--   
--   If, at any point, a change value is generated that is less than or
--   equal to the <a>DustThreshold</a>, this function will eliminate that
--   change value from the <a>change</a> set, redistributing the eliminated
--   value over the remaining change values, ensuring that the total value
--   of all <a>change</a> is preserved.
--   
--   See <a>coalesceDust</a> for more details.
--   
--   <h2>Termination</h2>
--   
--   Since adjusting a selection can affect the fee estimate produced by
--   <a>estimateFee</a>, the process of adjustment is an <i>iterative</i>
--   process.
--   
--   The termination post-condition depends on the choice of
--   <a>FeeBalancingPolicy</a>:
--   
--   <ul>
--   <li>If <a>RequireBalancedFee</a> is specified, this function
--   terminates only when it has generated a <a>CoinSelection</a>
--   <b><tt>s</tt></b> that satisfies the following
--   property:<pre>&gt;&gt;&gt; sumInputs s = sumOutputs s + sumChange s +
--   estimateFee s </pre></li>
--   <li>If <a>RequireMinimalFee</a> policy is specified, the above
--   <i>equality</i> is relaxed to the following
--   <i>inequality</i>:<pre>&gt;&gt;&gt; sumInputs s ≥ sumOutputs s +
--   sumChange s + estimateFee s </pre></li>
--   </ul>
--   
--   See <a>FeeBalancingPolicy</a> for more details.
adjustForFee :: (Ord i, MonadRandom m) => FeeOptions i o -> CoinMap i -> CoinSelection i o -> ExceptT (FeeAdjustmentError i o) m (CoinSelection i o)

-- | Provides options for fee adjustment.
data FeeOptions i o
FeeOptions :: FeeEstimator i o -> DustThreshold -> FeeBalancingPolicy -> FeeOptions i o

-- | Estimate fees based on selected inputs and requested outputs.
[feeEstimator] :: FeeOptions i o -> FeeEstimator i o

-- | The threshold to use for dust elimination. Specifying a threshold of
--   zero will disable dust elimination. See <a>DustThreshold</a> for more
--   details.
[dustThreshold] :: FeeOptions i o -> DustThreshold

-- | What do to when we encounter a dangling change output. See
--   <a>FeeBalancingPolicy</a>
[feeBalancingPolicy] :: FeeOptions i o -> FeeBalancingPolicy

-- | A choice of fee balancing policies for use when adjusting a coin
--   selection.
--   
--   <h2>Background</h2>
--   
--   A coin selection <b><tt>s</tt></b> is said to have a
--   <i>perfectly-balanced</i> fee when it satisfies the following
--   property:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs s = sumOutputs s + sumChange s + estimateFee s
--   </pre>
--   
--   Conversely, a selection is said to have an <i>unbalanced</i> fee when
--   it satisfies the following property:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs s &gt; sumOutputs s + sumChange s + estimateFee s
--   </pre>
--   
--   In other words, if a coin selection has an <i>unbalanced</i> fee, the
--   <i>effective</i> fee is greater than the minimum fee <i>actually
--   required</i> by the blockchain.
--   
--   <h2>Balanced Fees vs Minimal Fees</h2>
--   
--   Some blockchains <i>require </i>that fees are always
--   <i>perfectly-balanced</i>.
--   
--   However, for blockchains that allow <i>unbalanced</i> fees, it is
--   sometimes possible to <i>save money</i> by generating a coin selection
--   with an unbalanced fee. This may seem counterintuitive at first, but
--   consider an individual change ouput <b><i>c</i></b> of value
--   <b><i>v</i></b>. If the <i>marginal fee</i> <b><i>f</i></b> associated
--   with <b><i>c</i></b> is greater than its value <b><i>v</i></b>, then
--   we will <i>save money</i> by <b>not</b> including <b><i>c</i></b>
--   within <a>change</a>.
--   
--   There are two policy choices available for handling change values with
--   marginal fees greater than their value:
--   
--   <ul>
--   <li>For blockchains that <b>allow</b> transactions with
--   <i>unbalanced</i> fees, specifying the <a>RequireMinimalFee</a> policy
--   will allow money to be saved by <i>excluding</i> change outputs that
--   have a marginal fee greater than their value.</li>
--   <li>For blockchains that do <b>not</b> allow transactions with
--   <i>unbalanced</i> fees, specifying the <a>RequireBalancedFee</a>
--   policy will always generate selections with fees that are
--   perfectly-balanced, even if the resulting fees are higher than could
--   be achieved by allowing unbalanced fees.</li>
--   </ul>
data FeeBalancingPolicy

-- | Generate selections with fees that are perfectly balanced, with the
--   trade-off of allowing slightly higher fees.
RequireBalancedFee :: FeeBalancingPolicy

-- | Generate selections with the lowest fees possible, with the trade-off
--   of allowing slightly imbalanced fees.
RequireMinimalFee :: FeeBalancingPolicy

-- | Represents the set of possible failures that can occur when adjusting
--   a <a>CoinSelection</a> with the <a>adjustForFee</a> function.
data FeeAdjustmentError i o

-- | Indicates that the given map of additional inputs was exhausted while
--   attempting to select extra inputs to cover the required fee.
--   
--   Records the shortfall (<b><i>f</i></b> − <b><i>s</i></b>) between the
--   required fee <b><i>f</i></b> and the total value <b><i>s</i></b> of
--   currently-selected inputs.
CannotCoverFee :: Fee -> FeeAdjustmentError i o

-- | Indicates that the given coin selection is <b>underfunded</b>: the
--   total value of <a>inputs</a> is less than the total value of
--   <a>outputs</a>, as calculated by the <a>coinMapValue</a> function.
CoinSelectionUnderfunded :: CoinSelection i o -> FeeAdjustmentError i o

-- | Defines the <i>maximum</i> size of a <b>dust coin</b>.
--   
--   Functions that accept a <a>DustThreshold</a> argument will generally
--   exclude values that are <i>less than or equal to</i> this threshold
--   from the <a>change</a> sets of generated selections, <i>coalescing</i>
--   such coins together into larger coins that <i>exceed</i> the
--   threshold.
--   
--   Specifying a dust threshold of <b><i>n</i></b> causes all coins that
--   are less than or equal to <b><i>n</i></b> to be treated as dust and
--   coalesced together.
--   
--   Specifying a dust threshold of <b>0</b> completely <i>disables</i>
--   dust elimination with the exception of zero-valued coins, which will
--   always be eliminated.
--   
--   See <a>coalesceDust</a>.
newtype DustThreshold
DustThreshold :: Coin -> DustThreshold
[unDustThreshold] :: DustThreshold -> Coin

-- | From the given list of coins, remove dust coins with a value less than
--   or equal to the given threshold value, redistributing their total
--   value over the coins that remain.
--   
--   This function satisfies the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; sum coins = sum (coalesceDust threshold coins)
--   
--   &gt;&gt;&gt; all (/= Coin 0) (coalesceDust threshold coins)
--   </pre>
coalesceDust :: DustThreshold -> NonEmpty Coin -> [Coin]
instance (GHC.Classes.Eq i, GHC.Classes.Eq o) => GHC.Classes.Eq (Cardano.CoinSelection.Fee.FeeAdjustmentError i o)
instance (GHC.Show.Show i, GHC.Show.Show o) => GHC.Show.Show (Cardano.CoinSelection.Fee.FeeAdjustmentError i o)
instance GHC.Generics.Generic (Cardano.CoinSelection.Fee.FeeOptions i o)
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.FeeBalancingPolicy
instance GHC.Show.Show Cardano.CoinSelection.Fee.FeeBalancingPolicy
instance GHC.Generics.Generic Cardano.CoinSelection.Fee.FeeBalancingPolicy
instance GHC.Generics.Generic (Cardano.CoinSelection.Fee.FeeEstimator i o)
instance GHC.Show.Show Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Classes.Ord Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Generics.Generic Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Show.Show Cardano.CoinSelection.Fee.Fee
instance GHC.Classes.Ord Cardano.CoinSelection.Fee.Fee
instance GHC.Generics.Generic Cardano.CoinSelection.Fee.Fee
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.Fee
instance GHC.Base.Semigroup Cardano.CoinSelection.Fee.Fee
instance GHC.Base.Monoid Cardano.CoinSelection.Fee.Fee


-- | This module contains an algorithm for migrating all funds from one
--   wallet to another.
--   
--   See <a>selectCoins</a>.
module Cardano.CoinSelection.Algorithm.Migration

-- | Creates a <b>series</b> of coin selections that, when published as
--   transactions, will have the effect of migrating all funds from one
--   wallet to another.
--   
--   Since UTxO-based blockchains typically impose limits on the sizes of
--   individual transactions, and since individual UTxO sets can contain
--   <i>arbitrarily</i> many entries, migrating all funds from one wallet
--   to another may require the creation of <i>several</i> transactions.
--   
--   This function therefore <i>partitions</i> the given set of inputs into
--   multiple <i>batches</i> of up to <b><i>b</i></b> inputs, where
--   <b><i>b</i></b> is specified by the given <a>BatchSize</a> parameter.
--   (See <a>idealBatchSize</a> for an automatic way to calculate a
--   suitable batch size.)
--   
--   For each batch of inputs, this function creates a separate
--   <a>CoinSelection</a> with the given <a>inputs</a> <i>and</i> a
--   generated <a>change</a> set, where the <a>change</a> set represents
--   the value to be transferred to the target wallet, carefully adjusted
--   to deduct a fee in accordance with the given <a>FeeOptions</a>
--   parameter. The set of <a>outputs</a> for each coin selection is
--   <i>purposefully</i> left empty, as <i>all</i> value is captured in the
--   <a>change</a> set.
selectCoins :: forall i o. (Ord i, Ord o) => FeeOptions i o -> BatchSize -> CoinMap i -> [CoinSelection i o]

-- | An upper limit for the number of <a>inputs</a> to include in each coin
--   selection generated by <a>selectCoins</a>.
newtype BatchSize
BatchSize :: Word16 -> BatchSize

-- | Calculate an ideal batch size based on the given coin selection limit.
idealBatchSize :: CoinSelectionLimit -> BatchSize
instance GHC.Show.Show Cardano.CoinSelection.Algorithm.Migration.BatchSize
instance GHC.Classes.Ord Cardano.CoinSelection.Algorithm.Migration.BatchSize
instance GHC.Generics.Generic Cardano.CoinSelection.Algorithm.Migration.BatchSize
instance GHC.Classes.Eq Cardano.CoinSelection.Algorithm.Migration.BatchSize
