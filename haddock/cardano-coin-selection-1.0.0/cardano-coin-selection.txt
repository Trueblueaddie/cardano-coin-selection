-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algorithms for coin selection and fee balancing.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-coin-selection</a>
@package cardano-coin-selection
@version 1.0.0


-- | Provides general functions and types relating to coin selection.
--   
--   The <a>CoinSelection</a> type represents a <b>coin selection</b>, the
--   basis for a <i>transaction</i> in a UTxO-based blockchain.
--   
--   The <a>CoinSelectionAlgorithm</a> type provides a <b>common
--   interface</b> to algorithms that generate coin selections.
module Cardano.CoinSelection

-- | A <b>coin selection</b> is the basis for a <i>transaction</i>.
--   
--   It consists of a selection of <a>inputs</a>, <a>outputs</a>, and
--   <a>change</a>.
--   
--   The <a>inputs</a> and <a>outputs</a> fields are both maps of unique
--   keys to associated <a>Coin</a> values, where:
--   
--   <ul>
--   <li>Each key-value pair in the <a>inputs</a> map corresponds to an
--   <b>unspent output</b> from a previous transaction (also known as a
--   UTxO). The <i>key</i> is a unique reference to that output, and the
--   <i>value</i> is the amount of unspent value associated with it.</li>
--   <li>Each key-value pair in the <a>outputs</a> map corresponds to a
--   <b>payment</b>. The <i>key</i> is a unique reference to a payment
--   recipient, and the <i>value</i> is the amount of money to pay to that
--   recipient.</li>
--   </ul>
--   
--   The <a>change</a> field is a set of coins to be returned to the
--   originator of the transaction.
--   
--   The <a>CoinSelectionAlgorithm</a> type provides a common interface for
--   generating coin selections.
data CoinSelection i o
CoinSelection :: CoinMap i -> CoinMap o -> [Coin] -> CoinSelection i o

-- | The set of inputs.
[inputs] :: CoinSelection i o -> CoinMap i

-- | The set of outputs.
[outputs] :: CoinSelection i o -> CoinMap o

-- | The set of change.
[change] :: CoinSelection i o -> [Coin]

-- | Calculate the total sum of all <a>inputs</a> for the given
--   <a>CoinSelection</a>.
sumInputs :: CoinSelection i o -> Coin

-- | Calculate the total sum of all <a>outputs</a> for the given
--   <a>CoinSelection</a>.
sumOutputs :: CoinSelection i o -> Coin

-- | Calculate the total sum of all <a>change</a> for the given
--   <a>CoinSelection</a>.
sumChange :: CoinSelection i o -> Coin

-- | Provides a <b>common interface</b> for coin selection algorithms.
--   
--   The function <a>selectCoins</a>, when applied to the given
--   <a>CoinSelectionParameters</a> object (with <i>available inputs</i>
--   and <i>requested</i> <i>outputs</i>), will generate a
--   <a>CoinSelectionResult</a> (with <i>remaining inputs</i> and a <i>coin
--   selection</i>).
newtype CoinSelectionAlgorithm i o m
CoinSelectionAlgorithm :: (CoinSelectionParameters i o -> ExceptT CoinSelectionError m (CoinSelectionResult i o)) -> CoinSelectionAlgorithm i o m
[selectCoins] :: CoinSelectionAlgorithm i o m -> CoinSelectionParameters i o -> ExceptT CoinSelectionError m (CoinSelectionResult i o)

-- | The complete set of parameters required for a
--   <a>CoinSelectionAlgorithm</a>.
--   
--   The <a>inputsAvailable</a> and <a>outputsRequested</a> fields are both
--   maps of unique keys to associated <a>Coin</a> values, where:
--   
--   <ul>
--   <li>Each key-value pair in the <a>inputsAvailable</a> map corresponds
--   to an <b>unspent output</b> from a previous transaction that is
--   <i>available</i> <i>for selection as an input</i> by the coin
--   selection algorithm. The <i>key</i> is a unique reference to that
--   output, and the <i>value</i> is the amount of unspent value associated
--   with it.</li>
--   <li>Each key-value pair in the <a>outputsRequested</a> map corresponds
--   to a <b>payment</b> whose value is <i>to be paid for</i> by the coin
--   selection algorithm. The <i>key</i> is a unique reference to a payment
--   recipient, and the <i>value</i> is the amount of money to pay to that
--   recipient.</li>
--   </ul>
--   
--   A coin selection algorithm will select a <b>subset</b> of inputs from
--   <a>inputsAvailable</a> in order to pay for <b>all</b> the outputs in
--   <a>outputsRequested</a>, where:
--   
--   <ul>
--   <li>Inputs <b>selected</b> by the algorithm are included in the
--   <a>inputs</a> set of the generated <a>CoinSelection</a>.</li>
--   <li>Inputs <b>not</b> selected by the algorithm are included in the
--   <a>inputsRemaining</a> set of the <a>CoinSelectionResult</a>.</li>
--   </ul>
--   
--   The number of inputs that can selected is limited by <a>limit</a>.
--   
--   The total value of <a>inputsAvailable</a> must be <i>greater than or
--   equal to</i> the total value of <a>outputsRequested</a>, as given by
--   the <a>coinMapValue</a> function.
data CoinSelectionParameters i o
CoinSelectionParameters :: CoinMap i -> CoinMap o -> CoinSelectionLimit -> CoinSelectionParameters i o

-- | The set of inputs available for selection.
[inputsAvailable] :: CoinSelectionParameters i o -> CoinMap i

-- | The set of outputs requested for payment.
[outputsRequested] :: CoinSelectionParameters i o -> CoinMap o

-- | A limit on the number of inputs that can be selected.
[limit] :: CoinSelectionParameters i o -> CoinSelectionLimit

-- | Represents the <b>result</b> of running a coin selection algorithm.
--   
--   See <a>CoinSelectionAlgorithm</a>.
data CoinSelectionResult i o
CoinSelectionResult :: CoinSelection i o -> CoinMap i -> CoinSelectionResult i o

-- | The generated coin selection.
[coinSelection] :: CoinSelectionResult i o -> CoinSelection i o

-- | The set of inputs that were <b>not</b> selected.
[inputsRemaining] :: CoinSelectionResult i o -> CoinMap i

-- | Defines an <b>inclusive upper bound</b> on the <i>number</i> of inputs
--   that a <a>CoinSelectionAlgorithm</a> is allowed to select.
newtype CoinSelectionLimit
CoinSelectionLimit :: (Word16 -> Word16) -> CoinSelectionLimit

-- | Calculate the maximum number of inputs allowed for a given number of
--   outputs.
[calculateLimit] :: CoinSelectionLimit -> Word16 -> Word16

-- | Represents a non-negative integral amount of currency.
--   
--   Use <a>coinFromNatural</a> to create a coin from a natural number.
--   
--   Use <a>coinToNatural</a> to convert a coin into a natural number.
data Coin

-- | Creates a coin from a natural number.
coinFromNatural :: Natural -> Coin

-- | Converts the given coin into a natural number.
coinToNatural :: Coin -> Natural

-- | A mapping from unique keys to associated <a>Coin</a> values.
--   
--   A <a>CoinMap</a> can be used to represent:
--   
--   <ul>
--   <li>a UTxO set, where each key within the map refers to an unspent
--   output from a previous transaction.</li>
--   <li>a set of <a>inputs</a> to a <a>CoinSelection</a>, where each input
--   is an entry selected from a UTxO set by a
--   <a>CoinSelectionAlgorithm</a>.</li>
--   <li>a set of <a>outputs</a> for a <a>CoinSelection</a>, where each key
--   within the map refers to the address of a payment recipient.</li>
--   </ul>
--   
--   A <a>CoinMap</a> can be constructed with the <a>coinMapFromList</a>
--   function.
--   
--   The total value of a <a>CoinMap</a> is given by the
--   <a>coinMapValue</a> function.
newtype CoinMap a
CoinMap :: Map a Coin -> CoinMap a
[unCoinMap] :: CoinMap a -> Map a Coin

-- | An entry for a <a>CoinMap</a>.
data CoinMapEntry a
CoinMapEntry :: a -> Coin -> CoinMapEntry a

-- | The unique key associated with this entry.
[entryKey] :: CoinMapEntry a -> a

-- | The coin value associated with this entry.
[entryValue] :: CoinMapEntry a -> Coin

-- | Constructs a <a>CoinMap</a> from a list of entries.
--   
--   See <a>CoinMapEntry</a>.
coinMapFromList :: Ord a => [CoinMapEntry a] -> CoinMap a

-- | Converts a <a>CoinMap</a> to a list of entries.
--   
--   See <a>CoinMapEntry</a>.
coinMapToList :: CoinMap a -> [CoinMapEntry a]

-- | Calculates the total coin value associated with a <a>CoinMap</a>.
coinMapValue :: CoinMap a -> Coin

-- | Represents the set of possible failures that can occur when attempting
--   to produce a <a>CoinSelection</a> with a
--   <a>CoinSelectionAlgorithm</a>.
--   
--   See <a>selectCoins</a>.
data CoinSelectionError
InputValueInsufficient :: InputValueInsufficientError -> CoinSelectionError
InputCountInsufficient :: InputCountInsufficientError -> CoinSelectionError
InputLimitExceeded :: InputLimitExceededError -> CoinSelectionError
InputsExhausted :: InputsExhaustedError -> CoinSelectionError

-- | Indicates that the total value of <a>inputsAvailable</a> is less than
--   the total value of <a>outputsRequested</a>, making it
--   <i>impossible</i> to cover all payments, <i>regardless</i> of which
--   algorithm is chosen.
data InputValueInsufficientError
InputValueInsufficientError :: Coin -> Coin -> InputValueInsufficientError

-- | The total value of <a>inputsAvailable</a>.
[inputValueAvailable] :: InputValueInsufficientError -> Coin

-- | The total value of <a>outputsRequested</a>.
[inputValueRequired] :: InputValueInsufficientError -> Coin

-- | Indicates that the total count of entries in <a>inputsAvailable</a> is
--   <i>fewer</i> <i>than</i> required by the algorithm. The number
--   required depends on the particular algorithm implementation.
data InputCountInsufficientError
InputCountInsufficientError :: Natural -> Natural -> InputCountInsufficientError

-- | The number of entries in <a>inputsAvailable</a>.
[inputCountAvailable] :: InputCountInsufficientError -> Natural

-- | The number of entries required.
[inputCountRequired] :: InputCountInsufficientError -> Natural

-- | Indicates that the coin selection algorithm is unable to cover the
--   total value of <a>outputsRequested</a> without exceeding the maximum
--   number of inputs defined by <a>limit</a>.
--   
--   See <a>calculateLimit</a>.
newtype InputLimitExceededError
InputLimitExceededError :: Word16 -> InputLimitExceededError
[calculatedInputLimit] :: InputLimitExceededError -> Word16

-- | Indicates that all available entries in <a>inputsAvailable</a> were
--   depleted <i>before</i> all the payments in <a>outputsRequested</a>
--   could be paid for.
--   
--   This condition can occur <i>even if</i> the total value of
--   <a>inputsAvailable</a> is greater than or equal to the total value of
--   <a>outputsRequested</a>, due to differences in the way that algorithms
--   select inputs.
data InputsExhaustedError
InputsExhaustedError :: InputsExhaustedError
instance GHC.Show.Show Cardano.CoinSelection.CoinSelectionError
instance GHC.Classes.Eq Cardano.CoinSelection.CoinSelectionError
instance GHC.Show.Show Cardano.CoinSelection.InputLimitExceededError
instance GHC.Classes.Eq Cardano.CoinSelection.InputLimitExceededError
instance GHC.Show.Show Cardano.CoinSelection.InputsExhaustedError
instance GHC.Classes.Eq Cardano.CoinSelection.InputsExhaustedError
instance GHC.Show.Show Cardano.CoinSelection.InputCountInsufficientError
instance GHC.Classes.Eq Cardano.CoinSelection.InputCountInsufficientError
instance GHC.Show.Show Cardano.CoinSelection.InputValueInsufficientError
instance GHC.Classes.Eq Cardano.CoinSelection.InputValueInsufficientError
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinSelectionParameters i o)
instance GHC.Generics.Generic Cardano.CoinSelection.CoinSelectionLimit
instance (GHC.Classes.Eq i, GHC.Classes.Eq o) => GHC.Classes.Eq (Cardano.CoinSelection.CoinSelection i o)
instance (GHC.Show.Show i, GHC.Show.Show o) => GHC.Show.Show (Cardano.CoinSelection.CoinSelection i o)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinSelection i o)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.CoinSelection.CoinMapEntry a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.CoinSelection.CoinMap a)
instance GHC.Generics.Generic (Cardano.CoinSelection.CoinMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.CoinSelection.CoinMap a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord o) => GHC.Base.Semigroup (Cardano.CoinSelection.CoinSelection i o)
instance (GHC.Classes.Ord i, GHC.Classes.Ord o) => GHC.Base.Monoid (Cardano.CoinSelection.CoinSelection i o)
instance Data.Foldable.Foldable Cardano.CoinSelection.CoinMap
instance GHC.Classes.Ord a => GHC.Base.Monoid (Cardano.CoinSelection.CoinMap a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Cardano.CoinSelection.CoinMap a)


-- | This module contains an implementation of the <b>Random-Improve</b>
--   coin selection algorithm.
module Cardano.CoinSelection.Algorithm.RandomImprove

-- | An implementation of the <b>Random-Improve</b> coin selection
--   algorithm.
--   
--   <h1>Overview</h1>
--   
--   The <b>Random-Improve</b> coin selection algorithm works in <b>two
--   phases</b>, by <i>first</i> selecting UTxO entries <i>at random</i> to
--   pay for each of the given outputs, and <i>then</i> attempting to
--   <i>improve</i> upon each of the selections.
--   
--   <h3>Phase 1: Random Selection</h3>
--   
--   <b>In this phase, the algorithm randomly selects a minimal set of
--   UTxO</b> <b>entries to pay for each of the given outputs.</b>
--   
--   During this phase, the algorithm:
--   
--   <ul>
--   <li>processes outputs in <i>descending order of coin value</i>.</li>
--   <li>maintains a <i>remaining UTxO set</i>, initially equal to the
--   given <i>UTxO set</i> parameter.</li>
--   </ul>
--   
--   For each output of value <b><i>v</i></b>, the algorithm
--   <i>randomly</i> selects entries from the <i>remaining UTxO set</i>,
--   until the total value of selected entries is greater than or equal to
--   <b><i>v</i></b>. The selected entries are then associated with that
--   output, and removed from the <i>remaining UTxO set</i>.
--   
--   This phase ends when every output has been associated with a selection
--   of UTxO entries.
--   
--   However, if the remaining UTxO set is completely exhausted before all
--   outputs can be processed, the algorithm terminates with an error.
--   
--   <h3>Phase 2: Improvement</h3>
--   
--   <b>In this phase, the algorithm attempts to improve upon each of the
--   UTxO</b> <b>selections made in the previous phase, by conservatively
--   expanding the</b> <b>selection made for each output.</b>
--   
--   During this phase, the algorithm:
--   
--   <ul>
--   <li>processes outputs in <i>ascending order of coin value</i>.</li>
--   <li>continues to maintain the <i>remaining UTxO set</i> produced by
--   the previous phase.</li>
--   <li>maintains an <i>accumulated coin selection</i>, which is initially
--   <i>empty</i>.</li>
--   </ul>
--   
--   For each output of value <b><i>v</i></b>, the algorithm:
--   
--   <ol>
--   <li><b>Calculates a <i>target range</i></b> for the total value of
--   inputs used to pay for that output, defined by the
--   triplet:(<i>minimum</i>, <i>ideal</i>, <i>maximum</i>) = (<i>v</i>,
--   <i>2v</i>, <i>3v</i>)</li>
--   <li><b>Attempts to <i>improve</i> upon the <i>existing UTxO
--   selection</i></b> for that output, by repeatedly selecting additional
--   entries at random from the <i>remaining UTxO set</i>, stopping when
--   the selection can be improved upon no further.A selection with value
--   <i>v1</i> is considered to be an <i>improvement</i> over a selection
--   with value <i>v0</i> if <b>all</b> of the following conditions are
--   satisfied:<ul><li><b>Condition 1</b>: we have moved closer to the
--   <i>ideal</i> value:abs (<i>ideal</i> − <i>v1</i>) &lt; abs
--   (<i>ideal</i> − <i>v0</i>)</li><li><b>Condition 2</b>: we have not
--   exceeded the <i>maximum</i> value:<i>v1</i> ≤
--   <i>maximum</i></li><li><b>Condition 3</b>: when counting cumulatively
--   across all outputs considered so far, we have not selected more than
--   the <i>maximum</i> number of UTxO entries specified by
--   <a>limit</a>.</li></ul></li>
--   <li><b>Creates a <i>change value</i></b> for the output, equal to the
--   total value of the <i>final UTxO selection</i> for that output minus
--   the value <i>v</i> of that output.</li>
--   <li><b>Updates the <i>accumulated coin selection</i></b>:<ul><li>Adds
--   the <i>output</i> to <a>outputs</a>.</li><li>Adds the <i>improved UTxO
--   selection</i> to <a>inputs</a>.</li><li>Adds the <i>change value</i>
--   to <a>change</a>.</li></ul></li>
--   </ol>
--   
--   This phase ends when every output has been processed, <b>or</b> when
--   the <i>remaining UTxO set</i> has been exhausted, whichever occurs
--   sooner.
--   
--   <h1>Termination</h1>
--   
--   When both phases are complete, the algorithm terminates.
--   
--   The <i>accumulated coin selection</i> and <i>remaining UTxO set</i>
--   are returned to the caller.
--   
--   <h3>Failure Modes</h3>
--   
--   The algorithm terminates with an <b>error</b> if:
--   
--   <ol>
--   <li>The <i>total value</i> of the initial UTxO set (the amount of
--   money <i>available</i>) is <i>less than</i> the total value of the
--   output list (the amount of money <i>required</i>).See:
--   <b><a>InputValueInsufficientError</a></b>.</li>
--   <li>The <i>number</i> of entries in the initial UTxO set is <i>smaller
--   than</i> the number of requested outputs.Due to the nature of the
--   algorithm, <i>at least one</i> UTxO entry is required <i>for each</i>
--   output.See: <b><a>InputCountInsufficientError</a></b>.</li>
--   <li>Due to the particular <i>distribution</i> of values within the
--   initial UTxO set, the algorithm depletes all entries from the UTxO set
--   <i>before</i> it is able to pay for all requested outputs.See:
--   <b><a>InputsExhaustedError</a></b>.</li>
--   <li>The <i>number</i> of UTxO entries needed to pay for the requested
--   outputs would <i>exceed</i> the upper limit specified by
--   <a>limit</a>.See: <b><a>InputLimitExceededError</a></b>.</li>
--   </ol>
--   
--   <h1>Motivating Principles</h1>
--   
--   There are several motivating principles behind the design of the
--   algorithm.
--   
--   <h3>Principle 1: Dust Management</h3>
--   
--   The probability that random selection will choose dust entries from a
--   UTxO set increases with the proportion of dust in the set.
--   
--   Therefore, for a UTxO set with a large amount of dust, there's a high
--   probability that a random subset will include a large amount of dust.
--   
--   <h3>Principle 2: Change Management</h3>
--   
--   Ideally, coin selection algorithms should, over time, create a UTxO
--   set that has <i>useful</i> outputs: outputs that will allow us to
--   process future payments with a minimum number of inputs.
--   
--   If for each payment request of value <b><i>v</i></b> we create a
--   change output of <i>roughly</i> the same value <b><i>v</i></b>, then
--   we will end up with a distribution of change values that matches the
--   typical value distribution of payment requests.
--   
--   <h3>Principle 3: Performance Management</h3>
--   
--   Searching the UTxO set for additional entries to improve our change
--   outputs is <i>only</i> useful if the UTxO set contains entries that
--   are sufficiently small enough. But it is precisely when the UTxO set
--   contains many small entries that it is less likely for a
--   randomly-chosen UTxO entry to push the total above the upper bound.
randomImprove :: (Ord i, Ord o, MonadRandom m) => CoinSelectionAlgorithm i o m


-- | This module contains an implementation of the <b>Largest-First</b>
--   coin selection algorithm.
module Cardano.CoinSelection.Algorithm.LargestFirst

-- | An implementation of the <b>Largest-First</b> coin selection
--   algorithm.
--   
--   <h1>Overview</h1>
--   
--   The <b>Largest-First</b> algorithm processes outputs in <i>descending
--   order of</i> <i>value</i>, from <i>largest</i> to <i>smallest</i>.
--   
--   For each output, it repeatedly selects the <i>largest</i> remaining
--   unspent UTxO entry until the value of selected entries is greater than
--   or equal to the value of that output.
--   
--   <h1>State Maintained by the Algorithm</h1>
--   
--   At all stages of processing, the algorithm maintains:
--   
--   <ol>
--   <li>A <b><i>remaining UTxO list</i></b>This is initially equal to the
--   given <i>initial UTxO set</i> parameter, sorted into <i>descending
--   order of coin value</i>.The <i>head</i> of the list is always the
--   remaining UTxO entry with the <i>largest coin value</i>.Entries are
--   incrementally removed from the <i>head</i> of the list as the
--   algorithm proceeds, until the list is empty.</li>
--   <li>An <b><i>unpaid output list</i></b>This is initially equal to the
--   given <i>output list</i> parameter, sorted into <i>descending order of
--   coin value</i>.The <i>head</i> of the list is always the unpaid output
--   with the <i>largest coin value</i>.Entries are incrementally removed
--   from the <i>head</i> of the list as the algorithm proceeds, until the
--   list is empty.</li>
--   <li>An <b><i>accumulated coin selection</i></b>This is initially
--   <i>empty</i>.Entries are incrementally added as each output is paid
--   for, until the <i>unpaid output list</i> is empty.</li>
--   </ol>
--   
--   <h1>Cardinality Rules</h1>
--   
--   The algorithm requires that:
--   
--   <ol>
--   <li>Each output from the given <i>output list</i> is paid for by
--   <i>one or more</i> entries from the <i>initial UTxO set</i>.</li>
--   <li>Each entry from the <i>initial UTxO set</i> is used to pay for
--   <i>at most one</i> output from the given <i>output list</i>.(A single
--   UTxO entry <b>cannot</b> be used to pay for multiple outputs.)</li>
--   </ol>
--   
--   <h1>Order of Processing</h1>
--   
--   The algorithm proceeds according to the following sequence of steps:
--   
--   <ul>
--   <li><i>Step 1</i>Remove a single <i>unpaid output</i> from the head of
--   the <i>unpaid output list</i>.</li>
--   <li><i>Step 2</i>Repeatedly remove UTxO entries from the head of the
--   <i>remaining UTxO list</i> until the total value of entries removed is
--   <i>greater than or equal to</i> the value of the <i>removed
--   output</i>.</li>
--   <li><i>Step 3</i>Use the <i>removed UTxO entries</i> to pay for the
--   <i>removed output</i>.This is achieved by:<ul><li>adding the
--   <i>removed UTxO entries</i> to the <a>inputs</a> field of the
--   <i>accumulated coin selection</i>.</li><li>adding the <i>removed
--   output</i> to the <a>outputs</a> field of the <i>accumulated coin
--   selection</i>.</li></ul></li>
--   <li><i>Step 4</i>If the <i>total value</i> of the <i>removed UTxO
--   entries</i> is greater than the value of the <i>removed output</i>,
--   generate a coin whose value is equal to the exact difference, and add
--   it to the <a>change</a> field of the <i>accumulated coin
--   selection</i>.</li>
--   <li><i>Step 5</i>If the <i>unpaid output list</i> is empty,
--   <b>terminate</b> here.Otherwise, return to <i>Step 1</i>.</li>
--   </ul>
--   
--   <h1>Termination</h1>
--   
--   The algorithm terminates <b>successfully</b> if the <i>remaining UTxO
--   list</i> is not depleted before the <i>unpaid output list</i> can be
--   fully depleted (i.e., if all the outputs have been paid for).
--   
--   The <i>accumulated coin selection</i> and <i>remaining UTxO list</i>
--   are returned to the caller.
--   
--   <h3>Failure Modes</h3>
--   
--   The algorithm terminates with an <b>error</b> if:
--   
--   <ol>
--   <li>The <i>total value</i> of the initial UTxO set (the amount of
--   money <i>available</i>) is <i>less than</i> the total value of the
--   output list (the amount of money <i>required</i>).See:
--   <b><a>InputValueInsufficientError</a></b>.</li>
--   <li>The <i>number</i> of entries in the initial UTxO set is <i>smaller
--   than</i> the number of requested outputs.Due to the nature of the
--   algorithm, <i>at least one</i> UTxO entry is required <i>for each</i>
--   output.See: <b><a>InputCountInsufficientError</a></b>.</li>
--   <li>Due to the particular <i>distribution</i> of values within the
--   initial UTxO set, the algorithm depletes all entries from the UTxO set
--   <i>before</i> it is able to pay for all requested outputs.See:
--   <b><a>InputsExhaustedError</a></b>.</li>
--   <li>The <i>number</i> of UTxO entries needed to pay for the requested
--   outputs would <i>exceed</i> the upper limit specified by
--   <a>limit</a>.See: <b><a>InputLimitExceededError</a></b>.</li>
--   </ol>
largestFirst :: (Ord i, Ord o, Monad m) => CoinSelectionAlgorithm i o m


-- | Provides functionality for <b>adjusting</b> coin selections in order
--   to pay for transaction <b>fees</b>.
module Cardano.CoinSelection.Fee

-- | Represents a non-negative fee to be paid on a transaction.
newtype Fee
Fee :: Coin -> Fee
[unFee] :: Fee -> Coin

-- | Provides a function capable of estimating the fee for a given coin
--   selection.
--   
--   The fee estimate can depend on the numbers of inputs, outputs, and
--   change outputs within the coin selection, as well as their magnitudes.
newtype FeeEstimator i o
FeeEstimator :: (CoinSelection i o -> Fee) -> FeeEstimator i o
[estimateFee] :: FeeEstimator i o -> CoinSelection i o -> Fee

-- | Adjusts the given <a>CoinSelection</a> in order to pay for a
--   <b>transaction</b> <b>fee</b>, required in order to publish the
--   selection as a transaction on a blockchain.
--   
--   <h2>Background</h2>
--   
--   Implementations of <a>CoinSelectionAlgorithm</a> generally produce
--   coin selections that are <i>exactly balanced</i>, satisfying the
--   following equality:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs c = sumOutputs c + sumChange c
--   </pre>
--   
--   In order to pay for a transaction fee, the above equality must be
--   transformed into an <i>inequality</i>:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs c &gt; sumOutputs c + sumChange c
--   </pre>
--   
--   The difference between these two sides represents value to be paid
--   <i>by the</i> <i>originator</i> of the transaction, in the form of a
--   fee:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs c = sumOutputs c + sumChange c + fee
--   </pre>
--   
--   <h2>The Adjustment Process</h2>
--   
--   In order to generate a fee that is acceptable to the network, this
--   function adjusts the <a>change</a> and <a>inputs</a> of the given
--   <a>CoinSelection</a>, consulting the <a>FeeEstimator</a> as a guide
--   for how much the current selection would cost to publish as a
--   transaction on the network.
--   
--   <h2>Methods of Adjustment</h2>
--   
--   There are two methods of adjustment possible:
--   
--   <ol>
--   <li>The <b><a>change</a></b> set can be <i>reduced</i>, either by:a.
--   completely removing a change value from the set; or byb. reducing a
--   change value to a lower value.</li>
--   <li>The <b><a>inputs</a></b> set can be <i>augmented</i>, by selecting
--   additional inputs from the specified <a>CoinMap</a> argument.</li>
--   </ol>
--   
--   <h2>Dealing with Dust Values</h2>
--   
--   If, at any point, a change value is generated that is less than or
--   equal to the <a>DustThreshold</a>, this function will eliminate that
--   change value from the <a>change</a> set, redistributing the eliminated
--   value over the remaining change values, ensuring that the total value
--   of all <a>change</a> is preserved.
--   
--   See <a>coalesceDust</a> for more details.
--   
--   <h2>Termination</h2>
--   
--   Since adjusting a selection can affect the fee estimate produced by
--   <a>estimateFee</a>, the process of adjustment is an <i>iterative</i>
--   process.
--   
--   This function terminates when it has generated a <a>CoinSelection</a>
--   that satisfies the following property:
--   
--   <pre>
--   &gt;&gt;&gt; sumInputs c ≈ sumOutputs c + sumChange c + estimateFee c
--   </pre>
adjustForFee :: (Ord i, Show i, Show o, MonadRandom m) => FeeOptions i o -> CoinMap i -> CoinSelection i o -> ExceptT FeeAdjustmentError m (CoinSelection i o)

-- | Provides options for fee adjustment.
data FeeOptions i o
FeeOptions :: FeeEstimator i o -> DustThreshold -> FeeOptions i o
[feeEstimator] :: FeeOptions i o -> FeeEstimator i o
[dustThreshold] :: FeeOptions i o -> DustThreshold

-- | Represents the set of possible failures that can occur when adjusting
--   a <a>CoinSelection</a> with the <a>adjustForFee</a> function.
newtype FeeAdjustmentError

-- | Indicates that the given map of additional inputs was exhausted while
--   attempting to select extra inputs to cover the required fee.
--   
--   Records the shortfall (<b><i>f</i></b> − <b><i>s</i></b>) between the
--   required fee <b><i>f</i></b> and the total value <b><i>s</i></b> of
--   currently-selected inputs.
CannotCoverFee :: Fee -> FeeAdjustmentError

-- | Defines the maximum size of a dust coin.
--   
--   Change values that are less than or equal to this threshold will not
--   be included in coin selections produced by the <a>adjustForFee</a>
--   function.
newtype DustThreshold
DustThreshold :: Coin -> DustThreshold
[unDustThreshold] :: DustThreshold -> Coin

-- | From the given list of coins, remove dust coins with a value less than
--   or equal to the given threshold value, redistributing their total
--   value over the coins that remain.
--   
--   This function satisfies the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; sum coins = sum (coalesceDust threshold coins)
--   
--   &gt;&gt;&gt; all (/= Coin 0) (coalesceDust threshold coins)
--   </pre>
coalesceDust :: DustThreshold -> NonEmpty Coin -> [Coin]
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.FeeAdjustmentError
instance GHC.Show.Show Cardano.CoinSelection.Fee.FeeAdjustmentError
instance GHC.Generics.Generic (Cardano.CoinSelection.Fee.FeeOptions i o)
instance GHC.Generics.Generic (Cardano.CoinSelection.Fee.FeeEstimator i o)
instance GHC.Show.Show Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Classes.Ord Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Generics.Generic Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.DustThreshold
instance GHC.Show.Show Cardano.CoinSelection.Fee.Fee
instance GHC.Classes.Ord Cardano.CoinSelection.Fee.Fee
instance GHC.Generics.Generic Cardano.CoinSelection.Fee.Fee
instance GHC.Classes.Eq Cardano.CoinSelection.Fee.Fee
instance GHC.Base.Semigroup Cardano.CoinSelection.Fee.Fee
instance GHC.Base.Monoid Cardano.CoinSelection.Fee.Fee


-- | This module contains an algorithm to select coins for migration from
--   legacy wallets to newer wallets.
--   
--   We want users to be able to migrate their funds from a legacy random
--   wallet to a new sequential wallet. To do this, we have to move funds
--   from a wallet to another by making transactions. Funds are ultimately
--   a sum of many coins (a.k.a UTxOs). In a transaction, we can select a
--   few coins, and send them to addresses, effectively creating new coins
--   / UTxOs doing this.
--   
--   There are some limitations regarding the number of coins that can be
--   selected at once in a single transaction (theoretically 255 coins, in
--   practice ~170) because there's a transaction max size (in bytes)
--   enforced by the network. Also, there's a direct relationship between
--   the maximum number of inputs we can select, and the maximum number of
--   outputs we can produce (increasing one will decrease the other, and
--   vice-versa).
--   
--   When making a transaction, coins used as inputs for a transaction
--   becomes unavailable for a while, until the transaction is inserted
--   into the ledger and, make some new coins available as change (very
--   much like when paying with bank notes to a shop, if we give a 20 EUR
--   note to pay for 3 EUR, we can't spend the remaining 17 EUR before we
--   have received the change!). So, a wallet with a small number of UTxO
--   will not be able to make many transactions in parallel and will have
--   to make them sequentially, waiting for the previous ones to be
--   inserted before making new ones (we also say that a wallet is not
--   "fragmented enough").
module Cardano.CoinSelection.Algorithm.Migration

-- | Construct a list of coin selections / transactions to transfer the
--   totality of a user's wallet. The resulting <a>CoinSelection</a> do not
--   contain any <a>outputs</a>, but only change coins (so there's no
--   restriction about how addresses are generated).
--   
--   It tries to fit as many inputs as possible in a single transaction
--   (fixed by the <a>Word16</a> maximum number of inputs given as
--   argument.
--   
--   The fee options are used to balance the coin selections and fix a
--   threshold for dust that is removed from the selections.
selectCoins :: forall i o. (Ord i, Ord o) => FeeOptions i o -> Word16 -> CoinMap i -> [CoinSelection i o]
